package net.jgf.messaging;

import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import net.jgf.config.Configurable;
import net.jgf.core.JgfRuntimeException;
import net.jgf.core.service.BaseService;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;

/**
 * Main class for the messaging system. This is where all the observers are
 * registered. All MessageEvents are relayed by this class.
 * @author Schrijver
 * @version 1.0
 */
@Configurable
public final class MessageBroker extends BaseService {

    /**
     * Class logger.
     */
    private static final Logger logger = Logger.getLogger(MessageBroker.class);

    /**
     * Subscribers are mapped to the topic they are subscribing. It is possible
     * for a subscriber to appear more then once in the Map if they subscribe to
     * more the one topic.
     */
    private static Map < String, List < MessageSubscriber >> subscriptions = 
        new LinkedHashMap < String, List < MessageSubscriber >>();

    /**
     * Publishers are mapped to their publisher key. This key is generated by
     * the MessageBroker and is needed for callback methods. These callback
     * methods are to let the publisher know if their message is delivered or
     * not.
     */
    private static Map < String, MessagePublisher >          publishers    = 
        new LinkedHashMap < String, MessagePublisher >();

    /**
     * Constructor.
     */
    public MessageBroker() {
    }

    /**
     * Register the supplied MessageEventPublisher.
     * @param publisher MessagePublisher to register.
     */
    public void registerMessagePublisher(MessagePublisher publisher) {
        if (publishers.get(publisher.getId()) != null) {
            // a publisher is already registered under this Id. This should not
            // happen so we need to throw an exception.
            throw new JgfRuntimeException("Duplicate Publisher ID. " + publisher.getId());
        }
        publishers.put(publisher.getId(), publisher);
    }

    /**
     * Register the supplied MessageSubscriber.
     * @param subscriber MessageSubscriber to register.
     * @param topic The topic to which this subscriber wants to be subscribed.
     */
    public void registerMessageSubscriber(MessageSubscriber subscriber, String topic) {
        List < MessageSubscriber > subscriberList = subscriptions.get(topic);
        if (subscriberList == null || subscriberList.size() == 0) {
            subscriberList = new LinkedList < MessageSubscriber >();
        }
        subscriberList.add(subscriber);
        subscriptions.put(topic, subscriberList);
    }

    /**
     * Publishes the message to the MessageBroker with the specified topic. The
     * topic is then used as a first level filter to determine which subscribers
     * will receive the message.
     * @param message The message to publish
     * @param publisherKey key which identifies the publisher. Used to send
     *            notifications back to the publisher. Currently the only
     *            notification is the NO_SUBSCRIBERS notification.
     */
    public void publishMessage(BaseJGFMessage message, String publisherKey) {
        if (StringUtils.isEmpty(message.getTopic())) {
            throw new JgfRuntimeException("No topic in message from publisher " + publisherKey);
        }
        logger.info("topic: " + message.getTopic());
        List < MessageSubscriber > subscriberList = subscriptions.get(message.getTopic());
        if (subscriberList != null && subscriberList.size() > 0) {
            logger.info(subscriberList.size() + " subscribers found.");
            for (MessageSubscriber subscriber : subscriberList) {
                logger.info("sending message to subscriber " + subscriber.getClass().getName());
                subscriber.receiveMessage(message);
            }
        } else {
            publishers.get(publisherKey).receiveNotification(message, MessageNotifications.NO_SUBSCRIBERS);
        }
    }
}
